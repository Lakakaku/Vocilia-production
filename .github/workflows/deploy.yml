name: CD - Deploy to Production

on:
  workflow_run:
    workflows: ["CI - Build, Test, and Security"]
    branches: [main]
    types: [completed]
  
  # Manual deployment trigger
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      version:
        description: 'Version to deploy (leave empty for latest)'
        required: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  deploy-staging:
    runs-on: ubuntu-latest
    environment: staging
    if: github.event.workflow_run.conclusion == 'success' || github.event.inputs.environment == 'staging'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.STAGING_SSH_KEY }}

      - name: Deploy to staging
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} << 'EOF'
            cd /opt/ai-feedback-platform
            
            # Pull latest code
            git pull origin main
            
            # Update environment variables
            cp .env.staging .env.production
            
            # Run deployment script
            chmod +x scripts/deploy-prod.sh
            ./scripts/deploy-prod.sh
            
            # Run health check
            chmod +x scripts/health-check.sh
            ./scripts/health-check.sh
          EOF

      - name: Run smoke tests against staging
        run: |
          # Wait for deployment to settle
          sleep 60
          
          # Run smoke tests
          curl -f https://staging.feedback.your-domain.com/api/health
          curl -f https://staging.business.feedback.your-domain.com/api/health
          curl -f https://staging.admin.feedback.your-domain.com/api/health

      - name: Notify staging deployment
        uses: 8398a7/action-slack@v3
        if: always()
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          text: |
            Staging deployment ${{ job.status }}!
            Environment: https://staging.feedback.your-domain.com
            Commit: ${{ github.sha }}

  deploy-production:
    runs-on: ubuntu-latest
    environment: production
    needs: deploy-staging
    if: github.event.inputs.environment == 'production' || (github.ref == 'refs/heads/main' && needs.deploy-staging.result == 'success')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create deployment
        uses: actions/github-script@v7
        id: deployment
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'production',
              description: 'Production deployment',
              auto_merge: false
            });
            return deployment.data.id;

      - name: Set deployment status to in_progress
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.result }},
              state: 'in_progress',
              description: 'Deployment started'
            });

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.PRODUCTION_SSH_KEY }}

      - name: Create pre-deployment backup
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'EOF'
            cd /opt/ai-feedback-platform
            
            # Create database backup
            timestamp=$(date +"%Y%m%d_%H%M%S")
            docker-compose -f docker-compose.prod.yml exec -T postgres pg_dump -U postgres ai_feedback_platform > "backup_${timestamp}.sql"
            
            # Archive current deployment
            tar -czf "deployment_backup_${timestamp}.tar.gz" --exclude=node_modules --exclude=.git .
          EOF

      - name: Deploy to production
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'EOF'
            cd /opt/ai-feedback-platform
            
            # Pull latest code
            git pull origin main
            
            # Update production environment
            # Note: .env.production should be managed separately for security
            
            # Run deployment script
            chmod +x scripts/deploy-prod.sh
            ./scripts/deploy-prod.sh
          EOF

      - name: Wait for deployment to stabilize
        run: sleep 120

      - name: Run production health checks
        id: health_check
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'EOF'
            cd /opt/ai-feedback-platform
            chmod +x scripts/health-check.sh
            ./scripts/health-check.sh
          EOF

      - name: Run production smoke tests
        run: |
          # Test critical endpoints
          curl -f https://feedback.your-domain.com/api/health
          curl -f https://business.feedback.your-domain.com/api/health
          curl -f https://admin.feedback.your-domain.com/api/health
          
          # Test core functionality
          # Add more comprehensive tests here

      - name: Update deployment status to success
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.result }},
              state: 'success',
              description: 'Deployment completed successfully',
              environment_url: 'https://feedback.your-domain.com'
            });

      - name: Update deployment status to failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.result }},
              state: 'failure',
              description: 'Deployment failed'
            });

      - name: Rollback on failure
        if: failure()
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'EOF'
            cd /opt/ai-feedback-platform
            
            # Find the most recent backup
            latest_backup=$(ls -t deployment_backup_*.tar.gz | head -1)
            
            if [ -f "$latest_backup" ]; then
              echo "Rolling back to $latest_backup"
              
              # Stop current services
              docker-compose -f docker-compose.prod.yml down
              
              # Restore from backup
              tar -xzf "$latest_backup"
              
              # Restart services
              docker-compose -f docker-compose.prod.yml up -d
              
              echo "Rollback completed"
            else
              echo "No backup found for rollback"
            fi
          EOF

      - name: Notify production deployment
        uses: 8398a7/action-slack@v3
        if: always()
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          text: |
            üöÄ Production deployment ${{ job.status }}!
            Environment: https://feedback.your-domain.com
            Commit: ${{ github.sha }}
            ${{ job.status == 'failure' && 'Rollback initiated' || 'System is live!' }}

  monitor-deployment:
    runs-on: ubuntu-latest
    needs: deploy-production
    if: needs.deploy-production.result == 'success'
    
    steps:
      - name: Monitor deployment for 10 minutes
        run: |
          echo "Monitoring deployment health for 10 minutes..."
          
          for i in {1..10}; do
            echo "Health check $i/10..."
            
            # Check main endpoints
            if ! curl -f -s https://feedback.your-domain.com/api/health > /dev/null; then
              echo "‚ùå Customer PWA health check failed"
              exit 1
            fi
            
            if ! curl -f -s https://business.feedback.your-domain.com/api/health > /dev/null; then
              echo "‚ùå Business Dashboard health check failed"
              exit 1
            fi
            
            echo "‚úÖ Health check $i passed"
            sleep 60
          done
          
          echo "üéâ Deployment monitoring completed successfully!"

      - name: Notify monitoring completion
        uses: 8398a7/action-slack@v3
        if: always()
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          text: |
            üìä Post-deployment monitoring ${{ job.status }}
            The system has been stable for 10 minutes post-deployment.